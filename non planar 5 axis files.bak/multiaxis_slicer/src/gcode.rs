// G-code generation module

use crate::toolpath::{Toolpath, ToolpathSegment};
use std::fs::File;
use std::io::{self, Write};
use std::path::Path;

pub struct GCodeGenerator {
    pub filament_diameter: f64,
    pub nozzle_temp: f64,
    pub bed_temp: f64,
    pub retraction_distance: f64,
    pub retraction_speed: f64,
}

impl Default for GCodeGenerator {
    fn default() -> Self {
        Self {
            filament_diameter: 1.75,
            nozzle_temp: 210.0,
            bed_temp: 60.0,
            retraction_distance: 6.5,
            retraction_speed: 25.0,
        }
    }
}

impl GCodeGenerator {
    pub fn new() -> Self {
        Self::default()
    }

    /// Generate G-code from toolpaths and write to file
    pub fn generate<P: AsRef<Path>>(
        &self,
        toolpaths: &[Toolpath],
        output_path: P,
    ) -> io::Result<()> {
        let mut file = File::create(output_path)?;

        // Write header
        self.write_header(&mut file)?;

        // Write toolpaths
        let mut total_extrusion = 0.0;
        for toolpath in toolpaths {
            for segment in &toolpath.paths {
                self.write_move(&mut file, segment, &mut total_extrusion)?;
            }
        }

        // Write footer
        self.write_footer(&mut file)?;

        Ok(())
    }

    fn write_header(&self, file: &mut File) -> io::Result<()> {
        writeln!(file, "; Generated by multiaxis_slicer")?;
        writeln!(file, "; Filament diameter: {} mm", self.filament_diameter)?;
        writeln!(file)?;
        
        // Start G-code
        writeln!(file, "G21 ; Set units to millimeters")?;
        writeln!(file, "G90 ; Use absolute coordinates")?;
        writeln!(file, "M82 ; Use absolute extrusion")?;
        writeln!(file)?;
        
        // Heat up
        writeln!(file, "M104 S{} ; Set nozzle temp", self.nozzle_temp)?;
        writeln!(file, "M140 S{} ; Set bed temp", self.bed_temp)?;
        writeln!(file, "M109 S{} ; Wait for nozzle temp", self.nozzle_temp)?;
        writeln!(file, "M190 S{} ; Wait for bed temp", self.bed_temp)?;
        writeln!(file)?;
        
        // Homing and setup
        writeln!(file, "G28 ; Home all axes")?;
        writeln!(file, "G92 E0 ; Reset extruder")?;
        writeln!(file)?;

        Ok(())
    }

    fn write_move(
        &self,
        file: &mut File,
        segment: &ToolpathSegment,
        total_extrusion: &mut f64,
    ) -> io::Result<()> {
        *total_extrusion += segment.extrusion;

        // For 5-axis: Include A and B rotation axes
        // A = rotation around X axis
        // B = rotation around Y axis
        let (a_angle, b_angle) = self.orientation_to_angles(&segment.orientation);

        writeln!(
            file,
            "G1 X{:.3} Y{:.3} Z{:.3} A{:.3} B{:.3} E{:.5} F{:.0}",
            segment.position.x,
            segment.position.y,
            segment.position.z,
            a_angle,
            b_angle,
            *total_extrusion,
            segment.feedrate * 60.0 // Convert mm/s to mm/min
        )?;

        Ok(())
    }

    fn write_footer(&self, file: &mut File) -> io::Result<()> {
        writeln!(file)?;
        writeln!(file, "; End G-code")?;
        writeln!(
            file,
            "G1 E-{:.1} F{:.0} ; Retract",
            self.retraction_distance,
            self.retraction_speed * 60.0
        )?;
        writeln!(file, "M104 S0 ; Turn off nozzle")?;
        writeln!(file, "M140 S0 ; Turn off bed")?;
        writeln!(file, "G28 X Y ; Home X and Y")?;
        writeln!(file, "M84 ; Disable motors")?;

        Ok(())
    }

    /// Convert tool orientation vector to A and B angles (in degrees)
    fn orientation_to_angles(&self, orientation: &crate::geometry::Vector3D) -> (f64, f64) {
        // Project orientation to get rotation angles
        // A = rotation around X (pitch)
        // B = rotation around Y (roll)
        
        let a_angle = orientation.y.atan2(orientation.z).to_degrees();
        let b_angle = (-orientation.x).atan2(orientation.z).to_degrees();
        
        (a_angle, b_angle)
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::geometry::{Point3D, Vector3D};
    use crate::toolpath::ToolpathSegment;

    #[test]
    fn test_gcode_generation() {
        let generator = GCodeGenerator::new();
        
        let toolpath = Toolpath {
            z: 0.2,
            paths: vec![
                ToolpathSegment {
                    position: Point3D::new(0.0, 0.0, 0.2),
                    orientation: Vector3D::new(0.0, 0.0, 1.0),
                    extrusion: 0.1,
                    feedrate: 50.0,
                },
                ToolpathSegment {
                    position: Point3D::new(10.0, 0.0, 0.2),
                    orientation: Vector3D::new(0.0, 0.0, 1.0),
                    extrusion: 0.2,
                    feedrate: 50.0,
                },
            ],
        };

        let result = generator.generate(&[toolpath], "/tmp/test.gcode");
        assert!(result.is_ok());
    }
}
