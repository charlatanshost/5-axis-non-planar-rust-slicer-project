// G-code generation module

use crate::toolpath::{Toolpath, ToolpathSegment};
use std::fs::File;
use std::io::{self, Write};
use std::path::Path;

/// Which rotary-axis letters to emit in G-code moves.
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum RotaryAxisMode {
    /// A = pitch (rotation around X), B = roll (rotation around Y).
    /// This is the default for most 5-axis head machines.
    AB,
    /// B = tilt, C = rotate.
    /// Common on table-tilt / table-rotate machine configurations.
    BC,
}

impl Default for RotaryAxisMode {
    fn default() -> Self { Self::AB }
}

/// Machine kinematics parameters for 5-axis TCP compensation.
#[derive(Debug, Clone)]
pub struct MachineKinematics {
    /// Pivot-to-nozzle-tip distance in mm.
    /// Set to 0.0 to disable TCP compensation (default).
    pub tcp_offset: f64,
    /// Which axis labels to use when writing rotary moves.
    pub rotary_axes: RotaryAxisMode,
}

impl Default for MachineKinematics {
    fn default() -> Self {
        Self { tcp_offset: 0.0, rotary_axes: RotaryAxisMode::AB }
    }
}

pub struct GCodeGenerator {
    pub filament_diameter: f64,
    pub nozzle_temp: f64,
    pub bed_temp: f64,
    pub retraction_distance: f64,
    pub retraction_speed: f64,
    /// 5-axis machine kinematics (TCP offset + rotary axis labels).
    pub kinematics: MachineKinematics,
}

impl Default for GCodeGenerator {
    fn default() -> Self {
        Self {
            filament_diameter: 1.75,
            nozzle_temp: 210.0,
            bed_temp: 60.0,
            retraction_distance: 6.5,
            retraction_speed: 25.0,
            kinematics: MachineKinematics::default(),
        }
    }
}

impl GCodeGenerator {
    pub fn new() -> Self {
        Self::default()
    }

    /// Generate G-code from toolpaths and write to file
    pub fn generate<P: AsRef<Path>>(
        &self,
        toolpaths: &[Toolpath],
        output_path: P,
    ) -> io::Result<()> {
        let mut file = File::create(output_path)?;

        // Write header
        self.write_header(&mut file)?;

        // Write toolpaths
        let mut total_extrusion = 0.0;
        for toolpath in toolpaths {
            for segment in &toolpath.paths {
                self.write_move(&mut file, segment, &mut total_extrusion)?;
            }
        }

        // Write footer
        self.write_footer(&mut file)?;

        Ok(())
    }

    /// Generate G-code from toolpaths and return as vector of strings
    pub fn generate_to_string(&self, toolpaths: &[Toolpath]) -> Vec<String> {
        let total_layers = toolpaths.len();
        let total_segments: usize = toolpaths.iter().map(|tp| tp.paths.len()).sum();

        log::info!("G-code generation started:");
        log::info!("  Layers: {}", total_layers);
        log::info!("  Total segments: {}", total_segments);
        log::info!("  Estimated G-code lines: ~{}", total_segments + 30);

        let mut lines = Vec::with_capacity(total_segments + 30);

        // Header
        lines.push("; Generated by multiaxis_slicer".to_string());
        lines.push(format!("; Filament diameter: {} mm", self.filament_diameter));
        lines.push(String::new());
        lines.push("G21 ; Set units to millimeters".to_string());
        lines.push("G90 ; Use absolute coordinates".to_string());
        lines.push("M82 ; Use absolute extrusion".to_string());
        lines.push(String::new());
        lines.push(format!("M104 S{} ; Set nozzle temp", self.nozzle_temp));
        lines.push(format!("M140 S{} ; Set bed temp", self.bed_temp));
        lines.push(format!("M109 S{} ; Wait for nozzle temp", self.nozzle_temp));
        lines.push(format!("M190 S{} ; Wait for bed temp", self.bed_temp));
        lines.push(String::new());
        lines.push("G28 ; Home all axes".to_string());
        lines.push("G92 E0 ; Reset extruder".to_string());
        lines.push(String::new());

        // Toolpaths
        let mut total_extrusion = 0.0;
        let mut processed_segments = 0;
        let report_interval = (total_segments / 10).max(1000); // Report every 10% or 1000 segments

        for (layer_idx, toolpath) in toolpaths.iter().enumerate() {
            lines.push(format!("; LAYER:{}", layer_idx));
            lines.push(format!("; Z:{:.3}", toolpath.z));

            for segment in &toolpath.paths {
                let (a_angle, b_angle) = self.orientation_to_angles(&segment.orientation);
                let pos = self.tcp_compensate(segment.position, a_angle, b_angle);
                let (rot1, rot2) = self.format_rotary(a_angle, b_angle);

                if segment.extrusion < 1e-8 {
                    // Travel move: retract, rapid move, prime
                    lines.push(format!("G1 E{:.5} F{:.0} ; Retract",
                        total_extrusion - self.retraction_distance,
                        self.retraction_speed * 60.0));
                    lines.push(format!("G0 X{:.3} Y{:.3} Z{:.3} {} {} F6000 ; Travel",
                        pos.x, pos.y, pos.z, rot1, rot2));
                    lines.push(format!("G1 E{:.5} F{:.0} ; Prime",
                        total_extrusion,
                        self.retraction_speed * 60.0));
                } else {
                    // Extrusion move
                    total_extrusion += segment.extrusion;
                    lines.push(format!(
                        "G1 X{:.3} Y{:.3} Z{:.3} {} {} E{:.5} F{:.0}",
                        pos.x, pos.y, pos.z, rot1, rot2, total_extrusion,
                        segment.feedrate * 60.0));
                }

                processed_segments += 1;
                if processed_segments % report_interval == 0 {
                    let percent = (processed_segments as f32 / total_segments as f32 * 100.0) as u32;
                    log::info!("  G-code progress: {}% ({}/{} segments, layer {}/{})",
                        percent, processed_segments, total_segments, layer_idx + 1, total_layers);
                }
            }
        }

        log::info!("✓ G-code generation complete: {} lines", lines.len());

        // Footer
        lines.push(String::new());
        lines.push("; End G-code".to_string());
        lines.push(format!("G1 E-{:.1} F{:.0} ; Retract", self.retraction_distance, self.retraction_speed * 60.0));
        lines.push("M104 S0 ; Turn off nozzle".to_string());
        lines.push("M140 S0 ; Turn off bed".to_string());
        lines.push("G28 X Y ; Home X and Y".to_string());
        lines.push("M84 ; Disable motors".to_string());

        lines
    }

    fn write_header(&self, file: &mut File) -> io::Result<()> {
        writeln!(file, "; Generated by multiaxis_slicer")?;
        writeln!(file, "; Filament diameter: {} mm", self.filament_diameter)?;
        writeln!(file)?;
        
        // Start G-code
        writeln!(file, "G21 ; Set units to millimeters")?;
        writeln!(file, "G90 ; Use absolute coordinates")?;
        writeln!(file, "M82 ; Use absolute extrusion")?;
        writeln!(file)?;
        
        // Heat up
        writeln!(file, "M104 S{} ; Set nozzle temp", self.nozzle_temp)?;
        writeln!(file, "M140 S{} ; Set bed temp", self.bed_temp)?;
        writeln!(file, "M109 S{} ; Wait for nozzle temp", self.nozzle_temp)?;
        writeln!(file, "M190 S{} ; Wait for bed temp", self.bed_temp)?;
        writeln!(file)?;
        
        // Homing and setup
        writeln!(file, "G28 ; Home all axes")?;
        writeln!(file, "G92 E0 ; Reset extruder")?;
        writeln!(file)?;

        Ok(())
    }

    fn write_move(
        &self,
        file: &mut File,
        segment: &ToolpathSegment,
        total_extrusion: &mut f64,
    ) -> io::Result<()> {
        let (a_angle, b_angle) = self.orientation_to_angles(&segment.orientation);
        let pos = self.tcp_compensate(segment.position, a_angle, b_angle);
        let (rot1, rot2) = self.format_rotary(a_angle, b_angle);

        if segment.extrusion < 1e-8 {
            // Travel move: retract, rapid move, prime
            writeln!(file, "G1 E{:.5} F{:.0} ; Retract",
                *total_extrusion - self.retraction_distance,
                self.retraction_speed * 60.0)?;
            writeln!(file, "G0 X{:.3} Y{:.3} Z{:.3} {} {} F6000 ; Travel",
                pos.x, pos.y, pos.z, rot1, rot2)?;
            writeln!(file, "G1 E{:.5} F{:.0} ; Prime",
                *total_extrusion,
                self.retraction_speed * 60.0)?;
        } else {
            // Extrusion move
            *total_extrusion += segment.extrusion;
            writeln!(file, "G1 X{:.3} Y{:.3} Z{:.3} {} {} E{:.5} F{:.0}",
                pos.x, pos.y, pos.z, rot1, rot2, *total_extrusion,
                segment.feedrate * 60.0)?;
        }

        Ok(())
    }

    fn write_footer(&self, file: &mut File) -> io::Result<()> {
        writeln!(file)?;
        writeln!(file, "; End G-code")?;
        writeln!(
            file,
            "G1 E-{:.1} F{:.0} ; Retract",
            self.retraction_distance,
            self.retraction_speed * 60.0
        )?;
        writeln!(file, "M104 S0 ; Turn off nozzle")?;
        writeln!(file, "M140 S0 ; Turn off bed")?;
        writeln!(file, "G28 X Y ; Home X and Y")?;
        writeln!(file, "M84 ; Disable motors")?;

        Ok(())
    }

    /// Convert tool orientation vector to two rotation angles (in degrees).
    ///
    /// Returns `(axis1_deg, axis2_deg)` where the meaning of axis1 and axis2
    /// depends on `self.kinematics.rotary_axes`:
    /// - `AB`: axis1 = A (pitch around X), axis2 = B (roll around Y)
    /// - `BC`: axis1 = B (tilt), axis2 = C (rotate) — same math, different labels
    fn orientation_to_angles(&self, orientation: &crate::geometry::Vector3D) -> (f64, f64) {
        let a_angle = orientation.y.atan2(orientation.z).to_degrees();
        let b_angle = (-orientation.x).atan2(orientation.z).to_degrees();
        (a_angle, b_angle)
    }

    /// Apply TCP (tool center point) compensation.
    ///
    /// Shifts `position` so that the nozzle tip (which is `tcp_offset` mm below the
    /// pivot) lands at `position` when the head is tilted by `(a_deg, b_deg)`.
    /// Returns `position` unchanged when `tcp_offset ≈ 0`.
    fn tcp_compensate(&self, position: crate::geometry::Point3D, a_deg: f64, b_deg: f64)
        -> crate::geometry::Point3D
    {
        let offset = self.kinematics.tcp_offset;
        if offset.abs() < 1e-6 { return position; }
        let a = a_deg.to_radians();
        let b = b_deg.to_radians();
        crate::geometry::Point3D::new(
            position.x + offset * a.sin() * b.cos(),
            position.y + offset * a.sin() * b.sin(),
            position.z + offset * (1.0 - a.cos()),
        )
    }

    /// Format a rotary-axis pair for a G-code move according to the configured axis mode.
    fn format_rotary(&self, axis1_deg: f64, axis2_deg: f64) -> (String, String) {
        match self.kinematics.rotary_axes {
            RotaryAxisMode::AB => (format!("A{:.3}", axis1_deg), format!("B{:.3}", axis2_deg)),
            RotaryAxisMode::BC => (format!("B{:.3}", axis1_deg), format!("C{:.3}", axis2_deg)),
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::geometry::{Point3D, Vector3D};
    use crate::toolpath::ToolpathSegment;

    #[test]
    fn test_gcode_generation() {
        let generator = GCodeGenerator::new();
        
        let toolpath = Toolpath {
            z: 0.2,
            paths: vec![
                ToolpathSegment {
                    position: Point3D::new(0.0, 0.0, 0.2),
                    orientation: Vector3D::new(0.0, 0.0, 1.0),
                    extrusion: 0.1,
                    feedrate: 50.0,
                },
                ToolpathSegment {
                    position: Point3D::new(10.0, 0.0, 0.2),
                    orientation: Vector3D::new(0.0, 0.0, 1.0),
                    extrusion: 0.2,
                    feedrate: 50.0,
                },
            ],
        };

        let result = generator.generate(&[toolpath], "/tmp/test.gcode");
        assert!(result.is_ok());
    }
}
